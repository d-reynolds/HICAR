!-----------------------------------------------------------------------
! Snow transport by wind - Liston's scheme adapted to FSM 2.0
! References: Liston and Sturm (1998), Liston et al. (2007)
! Author: Glen E. Liston
! Adapted to FSM 2.0 by Louis QuÃ©no
! ATTENTION: y is the W->E axis, while x is the S->N
! South of (i,j): (i-1,j)
! North of (i,j): (i+1,j)
! West of (i,j): (i,j-1)
! East of (i,j): (i,j+1)
!-----------------------------------------------------------------------
module SNOWTRAN3D_interface

    use GRID, only: &
      Nx,Ny               ! Grid dimensions

    use CONSTANTS_SNOWTRAN3D, only: &
      wind_min            ! Minimum wind speed to compute snow transport (m/s)

!    use MODULES_interface, only: &
!      Qsalt_u,                &! Saltation flux, u-direction
!      Qsalt_v                  ! Saltation flux, v-direction

    implicit none
    
    private
    !!
    public :: SNOWTRAN3D_setup, SNOWTRAN3D_salt_start, SNOWTRAN3D_salt, SNOWTRAN3D_salt_end, SNOWTRAN3D_susp_start, SNOWTRAN3D_susp, SNOWTRAN3D_susp_end, SNOWTRAN3D_accum, Utau, Utau_t, Ds_soft

    real, save :: &
      bs_flag,           &! Blowing snow flag
      delta_WE,          &! Grid cell size in WE direction (m)
      delta_SN,          &! Grid cell size in SN direction (m)
      windspd_flag        ! Maximum wind speed on the domain (m/s)

    integer, save, allocatable, dimension(:,:) :: &
      index_ue, & ! Wind index array E
      index_uw, & ! Wind index array W
      index_vn, & ! Wind index array N
      index_vs    ! Wind index array S
    real, save, allocatable, dimension(:,:) :: &
      Ds_soft,           &! Soft snow thickness (m)
      snowthickness,     &! Depth of the snowpack in the snow covered part, i.e. not scaled by fsnow (m)
      uwind,             &! x component of wind speed (m/s)
      vwind,             &! y component of wind speed (m/s)
      Utau,              &! Friction velocity (m/s)
      Utau_t,            &! Threshold friction velocity (m/s)
      Qsalt_maxu,        &! x component of Qsalt_max (kg/m/s)
      Qsalt_maxv,        &! y component of Qsalt_max (kg/m/s)
      h_star,            &! Height of the saltation layer (m)
      z_0,               &! Surface roughness length (m)
      Qsalt,             &! Total saltation flux (kg/m/s)
      Qsubl,             &! Total sublimation loss from blowing snow(kg/m/s)
      dSWE_s_u,            &! change in mass from transport, U-direction
      dSWE_s_u_gain,       &! gain in mass from transport, U-direction
      dSWE_s_u_loss,       &! loss in mass from transport, U-direction
      dSWE_s_v,            &! change in mass from transport, V-direction
      dSWE_s_v_gain,       &! gain in mass from transport, V-direction
      dSWE_s_v_loss,       &! loss in mass from transport, V-direction
      dSWE_salt,           &! Net change in mass from saltation
      dSWE_susp,           &! Net change in mass from suspension
      snowdepth0,        &! Snow depth of snowdrift accumulation, averaged over the grid cell (m)
      Sice0               ! Surface layer ice content for transported snow (kg/m^2)

    contains


    subroutine SNOWTRAN3D_setup()

    use CONSTANTS, only: &
      pi,                &! pi
      rho_wat,           &! Density of water (kg/m^3)
      Tm                  ! Melting point (K)

    use DRIVING, only: &  
      Ua,                &! Wind speed (m/s)
      Udir                ! Wind direction (degrees, clockwise from N)

    use PARAMMAPS, only: &
      vegsnowd_xy         ! Vegetation snow holding capacity (m)

    use STATE_VARIABLES, only: &
      Ds,                &! Snow layer thicknesses (m)
      Nsnow,             &! Number of snow layers
      fsnow,             &! Snow cover fraction 
      Sice,              &! Ice content of snow layers (kg/m^2)
      Sliq,              &! Liquid content of snow layers (kg/m^2)
      Tsnow               ! Snow layer temperatures (K)

    use MODULES_interface, only: &
      firstit                   ! First iteration identifier    

    use LANDUSE, only: &
      Ld,                &! Grid cell size (m)
      dem                 ! Terrain elevation (m)

    use PARAM_SNOWTRAN3D, only: &
      Utau_t_flag,       &! Flag for variable threshold friction velocitiy (1.0) or constant (0.0)
      Utau_t_const,      &! Constant threshold friction velocity (m/s) used if Utau_t_flag = 0.0
      twolayer_flag,     &! Flag for soft/hard layers distinction
      rho_snow            ! Constant snow density (kg/m^3)

    implicit none

    integer :: &
      i,j                 ! Point counters
      
    real :: &
      veg_z0(Nx,Ny)


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


    !Initialize module level arrays if this is the first time running
      if (allocated(Ds_soft)) deallocate(Ds_soft)
      if (allocated(snowthickness)) deallocate(snowthickness)
      if (allocated(uwind)) deallocate(uwind)
      if (allocated(vwind)) deallocate(vwind)
      if (allocated(Utau)) deallocate(Utau)
      if (allocated(Utau_t)) deallocate(Utau_t)
      if (allocated(Qsalt_maxu)) deallocate(Qsalt_maxu)
      if (allocated(Qsalt_maxv)) deallocate(Qsalt_maxv)
      if (allocated(h_star)) deallocate(h_star)
      if (allocated(z_0)) deallocate(z_0)
      if (allocated(Qsalt)) deallocate(Qsalt)
      if (allocated(Qsubl)) deallocate(Qsubl)
      if (allocated(dSWE_s_u)) deallocate(dSWE_s_u)
      if (allocated(dSWE_s_u_gain)) deallocate(dSWE_s_u_gain)
      if (allocated(dSWE_s_u_loss)) deallocate(dSWE_s_u_loss)
      if (allocated(dSWE_s_v)) deallocate(dSWE_s_v)
      if (allocated(dSWE_s_v_gain)) deallocate(dSWE_s_v_gain)
      if (allocated(dSWE_s_v_loss)) deallocate(dSWE_s_v_loss)
      if (allocated(dSWE_salt)) deallocate(dSWE_salt)
      if (allocated(dSWE_susp)) deallocate(dSWE_susp)
      if (allocated(snowdepth0)) deallocate(snowdepth0)
      if (allocated(Sice0)) deallocate(Sice0)

      if (allocated(index_ue)) deallocate(index_ue)
      if (allocated(index_uw)) deallocate(index_uw)
      if (allocated(index_vn)) deallocate(index_vn)
      if (allocated(index_vs)) deallocate(index_vs)

      allocate(Ds_soft(Nx,Ny))
      allocate(snowthickness(Nx,Ny))
      allocate(uwind(Nx,Ny))
      allocate(vwind(Nx,Ny))
      allocate(Utau(Nx,Ny))
      allocate(Utau_t(Nx,Ny))
      allocate(Qsalt_maxu(Nx,Ny))
      allocate(Qsalt_maxv(Nx,Ny))
      allocate(h_star(Nx,Ny))
      allocate(z_0(Nx,Ny))
      allocate(Qsalt(Nx,Ny))
      allocate(Qsubl(Nx,Ny))
      allocate(dSWE_s_u(Nx,Ny))
      allocate(dSWE_s_u_gain(Nx,Ny))
      allocate(dSWE_s_u_loss(Nx,Ny))
      allocate(dSWE_s_v(Nx,Ny))
      allocate(dSWE_s_v_gain(Nx,Ny))
      allocate(dSWE_s_v_loss(Nx,Ny))
      allocate(dSWE_salt(Nx,Ny))
      allocate(dSWE_susp(Nx,Ny))
      allocate(snowdepth0(Nx,Ny))
      allocate(Sice0(Nx,Ny))

      allocate(index_ue(Nx,2*Ny+1))
      allocate(index_uw(Nx,2*Ny+1))
      allocate(index_vn(Ny,2*Nx+1))
      allocate(index_vs(Ny,2*Nx+1))

    ! Initialization of delta_WE and delta_SN
    delta_WE = Ld(1,1)
    delta_SN = Ld(1,1)

    ! Initialize Ds_soft
    Ds_soft(:,:) = 0.0

    ! Initialize snowdepth0 and Sice0
    snowdepth0(:,:) = 0.0
    Sice0(:,:) = 0.0


    ! Initialization of uwind and vwind
    uwind = Ua* cos(-Udir * pi/180.0 - pi/2.0)
    vwind = Ua* sin(-Udir * pi/180.0 - pi/2.0)

    ! Initialization of maximum wind speed on the domain (m/s)
    ! Originally in micromet_code.f
    ! Initialization of snowthickness
    windspd_flag = 0.0
    do j = 1, Ny
      do i = 1, Nx

        if (isnan(dem(i,j))) goto 1 ! Exclude points outside of the domain

        windspd_flag = max(windspd_flag,Ua(i,j))
        snowthickness(i,j) = sum(Ds(:,i,j))

        1 continue ! Exclude points outside of the domain

      end do
    end do

    ! Initialization of veg_z0 (copied from preprocess_code.f)
    ! Define the roughness lengths for each of the vegetation types.
    ! Note that this is pretty arbitrary, because these values are
    ! really only used when there is no blowing snow, and thus have
    ! no impact on the simulation except to provide a non-zero value
    ! for any such parts of the domain.
    veg_z0(:,:) = 0.25 * vegsnowd_xy(:,:)

    ! If the two-layer scheme is turned on, update the thicknesses
    ! of the hard and soft layers.
    if (twolayer_flag==1.0) then
      call compute_soft_snow()
    end if

    ! Update the threshold friction velocity.
    if (Utau_t_flag==0.0) then

      Utau_t(:,:) = Utau_t_const

    else if (Utau_t_flag==1.0) then

      call surface_snow()

    end if

    ! Set the blowing snow flag to zero until it is clear that we will
    ! have blowing snow.
    bs_flag = 0.0

    ! If the wind speed is lower that some threshold, then don't
    ! need to to any of the snow transport computations.
    !if (windspd_flag >= wind_min) then

      ! Get the wind direction indexing arrays for this particular
      ! wind event (time step).
      call getdirection()

      ! Solve for Utau and z_0 if snow is saltating, else solve assuming
      ! z_0 is known from snow depth and/or veg type, and solve for Utau.
      call solveUtau(veg_z0)

      ! Update Ds_soft by removing too dense layers compared to U_tau
      call update_soft_snow()

      ! If the blowing snow flag indicates wind transported snow
      ! somewhere within the domain (bs_flag = 1.0), run the saltation
      ! and suspension models.
      !if (bs_flag == 1.0) then
        ! Solve for the saltation flux.
        !call saltation_init(Qsalt_u,Qsalt_v)
      !endif
    !endif
      
    end subroutine SNOWTRAN3D_setup
      
      
    subroutine SNOWTRAN3D_accum(dSWE_salt_out,dSWE_susp_out,dSWE_subl_out)
    
    real, intent(inout) :: &
      dSWE_salt_out(Nx,Ny),    &! SWE change due to saltation (kg/m^2), to be output
      dSWE_susp_out(Nx,Ny),    &! SWE change due to suspension (kg/m^2), to be output
      dSWE_subl_out(Nx,Ny)      ! SWE change due to sublimation (kg/m^2), to be output
      

    ! Initialize all fluxes at 0
    dSWE_subl_out(:,:) = 0.0

    ! If the blowing snow flag indicates wind transported snow
    ! somewhere within the domain (bs_flag = 1.0), run the saltation
    ! and suspension models.
    if (bs_flag == 1.0) then

      ! Solve for the saltation flux.
      ! call saltation_accum(Qsalt_u,Qsalt_v,Qsalt)

      ! Solve for the suspension flux.
      ! call suspension(Qsalt,conc_salt,Qsusp,Qsusp_u,Qsusp_v,Qsubl)

    end if


    ! Compute the new snow depth due to accumulation from precipitation,
    ! saltation, and suspension, and the mass loss due to sublimation.
    call accum(dSWE_subl_out)
               
    ! Accumulation of new snow, calculation of snow cover fraction and relayering
    call SNOW_LAYERING(snowdepth0,Sice0)
               
    !These are calculated earlier, so copy them over now
    dSWE_salt_out = dSWE_salt
    dSWE_susp_out = dSWE_susp


    end subroutine SNOWTRAN3D_accum

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine compute_soft_snow()

    use STATE_VARIABLES, only: &
      Ds,                &! Snow layer thicknesses (m)
      Nsnow,             &! Number of snow layers
      histowet,          &! Historical variable for past wetting of a layer (0-1)
      Sliq                ! Liquid content of snow layers (kg/m^2)

    use LANDUSE, only: &
      dem                 ! Terrain elevation (m)

    implicit none

    integer :: &
      i,j,               &! Point counters
      k                   ! Layer counter

    ! New determination of soft snow based on layer wetting history and temperature
    ! Now histowet is used by default
    do i = 1, Nx
      do j = 1, Ny

        if (isnan(dem(i,j))) goto 2 ! Exclude points outside of the domain

        k = 1
        do while (Sliq(k,i,j) < epsilon(Sliq) .AND. histowet(k,i,j) < 0.5)
          Ds_soft(i,j) = Ds_soft(i,j) + Ds(k,i,j)
          k = k + 1
          if (k > Nsnow(i,j)) exit
        end do

        2 continue  ! Exclude points outside of the domain   

      end do
    end do

    end subroutine compute_soft_snow

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine update_soft_snow()

    use STATE_VARIABLES, only: &
      Ds,                &! Snow layer thicknesses (m)
      Nsnow,             &! Number of snow layers
      fsnow,             &! Snow cover fraction 
      Sice,              &! Ice content of snow layers (kg/m^2)
      Sliq                ! Liquid content of snow layers (kg/m^2)

    use LANDUSE, only: &
      dem                 ! Terrain elevation (m)

    implicit none

    integer :: &
      i,j,               &! Point counters
      k                   ! Layer counter

    logical :: &
      hard_layer_reached  ! A hard layer has been reached

    real :: &
      Ds_soft_old,       &! Soft snow thickness before update (m)
      rho_layer,         &! Snow layer density
      Utau_t_layer        ! Threshold friction velocity of each layer (m/s)

    do i = 1, Nx
      do j = 1, Ny

        if (isnan(dem(i,j))) goto 3 ! Exclude points outside of the domain

        Ds_soft_old = Ds_soft(i,j)
        Ds_soft(i,j) = 0.0
        hard_layer_reached = .FALSE.
        k = 1

        do while ((k <= Nsnow(i,j)) .AND. (Ds_soft_old - Ds_soft(i,j) > epsilon(Ds_soft)) .AND. (.NOT. hard_layer_reached))

          ! Calculate snow layer density
          rho_layer = (Sice(k,i,j) + Sliq(k,i,j)) / Ds(k,i,j) / fsnow(i,j)

          ! Calculate the snow threshold friction velocity.
          if (rho_layer <= 300.0) then
            Utau_t_layer = 0.10 * exp(0.003 * rho_layer)
          else
            Utau_t_layer = 0.005 * exp(0.013 * rho_layer)
          end if

          if (Utau(i,j) - Utau_t_layer > epsilon(Utau)) then
            Ds_soft(i,j) = Ds_soft(i,j) + Ds(k,i,j)
          else
            hard_layer_reached = .TRUE.
          end if

          k = k + 1

        end do

        3 continue  ! Exclude points outside of the domain   

      end do
    end do

    end subroutine update_soft_snow

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine accum(dSWE_subl)

    use CONSTANTS, only: &
      rho_wat                 ! Density of water (kg/m^3)

    use DRIVING, only: &
      dt                      ! Timestep (s)

    use PARAMMAPS, only: &
      vegsnowd_xy             ! Vegetation snow holding capacity (m)

    use STATE_VARIABLES, only: &
      Ds,                    &! Snow layer thicknesses (m)
      fsnow,                 &! Snow cover fraction 
      Sice,                  &! Ice content of snow layers (kg/m^2)
      Sliq,                  &! Liquid content of snow layers (kg/m^2)
      dSWE_tot_subl,         &! Cumulated SWE change due to sublimation (kg/m^2)
      dSWE_tot_salt,         &! Cumulated SWE change due to saltation (kg/m^2)
      dSWE_tot_susp           ! Cumulated SWE change due to suspension (kg/m^2)

    use LANDUSE, only: &
      dem                     ! Terrain elevation (m)

    use PARAM_SNOWTRAN3D, only: &
      rho_snow                ! Constant snow density (kg/m^3)

    implicit none

    real, intent(inout) :: &
      dSWE_subl(Nx,Ny)          ! SWE change due to sublimation (kg/m^2)

    integer :: &
      i,j                     ! Point counters

    real :: &
      dSWE_subl_loss,          &! SWE loss due to sublimation (kg/m^2)
      dh_subl_loss,          &! Snow depth loss due to sublimation (m)
      Ds_hard,               &! Hard snow thickness (m)
      swe_loc,               &! Total snowpack SWE (kg/m^2)
      snowdmin                ! Minimum snow depth to allow transport (m)

    if (bs_flag == 1.0) then

      ! SALTATION
      !call getnewdepth(Qsalt_u, &
      !                 Qsalt_v,dSWE_salt,snowdepth0,Sice0)

      ! SUSPENSION
      !call getnewdepth(Qsusp_u, &
      !                 Qsusp_v,dSWE_susp,snowdepth0,Sice0)

      ! SUBLIMATION
      do i = 2, Nx-1
        do j = 2, Ny-1

          if (isnan(dem(i,j))) goto 4 ! Exclude points outside of the domain

          ! Make adjustments for the case where there is no snow available
          ! on the ground (or captured within the vegetation) to be
          ! eroded.
          Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
          snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
          swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))

          ! Convert Qsubl to sublimated snow depth dh_subl_loss.
          dSWE_subl(i,j) = Qsubl(i,j) * dt * fsnow(i,j)
          dSWE_subl_loss = - dSWE_subl(i,j)
          dSWE_subl_loss = min(dSWE_subl_loss,swe_loc)
          if (dSWE_subl_loss > epsilon(dSWE_subl_loss)) then
            call HS_FROM_SWE(dSWE_subl_loss,dh_subl_loss,i,j)
          else
            dSWE_subl_loss = 0.0
            dh_subl_loss = 0.0
          end if

          if (snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow)) then
            if (snowthickness(i,j) - dh_subl_loss / fsnow(i,j) <= snowdmin) then
              dh_subl_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
              if (dh_subl_loss > epsilon(dh_subl_loss)) then
                call SWE_FROM_HS(dh_subl_loss,dSWE_subl_loss,i,j)
                dSWE_subl(i,j) = - dSWE_subl_loss
              else
                dh_subl_loss = 0.0
                dSWE_subl(i,j) = 0.0
              end if
            end if
          else
            dSWE_subl(i,j) = 0.0
            dSWE_subl_loss = 0.0
            dh_subl_loss = 0.0
          end if

          if (dSWE_subl_loss > epsilon(dSWE_subl_loss) .and. dh_subl_loss > epsilon(dh_subl_loss)) then
            call SNOW_ABLATION(dh_subl_loss,dSWE_subl_loss,i,j)
          end if

          ! Update the snow layer thicknesses
          snowthickness(i,j) = sum(Ds(:,i,j))

          4 continue  ! Exclude points outside of the domain

        end do
      end do

    end if

    ! Update cumulated sublimation and transport
    do i = 2, Nx-1
      do j = 2, Ny-1

        if (isnan(dem(i,j))) goto 5 ! Exclude points outside of the domain

        ! Fill summing arrays of the sublimation and transport quantities.
        dSWE_tot_subl(i,j) = dSWE_tot_subl(i,j) + dSWE_subl(i,j)
        dSWE_tot_salt(i,j) = dSWE_tot_salt(i,j) + dSWE_salt(i,j) 
        dSWE_tot_susp(i,j) = dSWE_tot_susp(i,j) + dSWE_susp(i,j)
    
        5 continue  ! Exclude points outside of the domain

      end do
    end do
    
    end subroutine accum

    subroutine SNOWTRAN3D_susp_start(Qs_u,Qs_v)
        implicit none
        
        real, intent(inout) :: &
         Qs_u(Nx,Ny),          &! x component of either Qsalt or Qsusp (kg/m/s)
         Qs_v(Nx,Ny)            ! y component of either Qsalt or Qsusp (kg/m/s)

        !Clear trans arrays
        Qs_u = 0.0
        dSWE_s_u = 0.0
        dSWE_s_u_gain = 0.0
        dSWE_s_u_loss = 0.0
        Qs_v = 0.0
        dSWE_s_v = 0.0
        dSWE_s_v_gain = 0.0
        dSWE_s_v_loss = 0.0
        
        dSWE_susp = 0.0
        Qsubl = 0.0

        ! If the blowing snow flag indicates wind transported snow
        ! somewhere within the domain (bs_flag = 1.0), run the saltation
        ! and suspension models.
        if (bs_flag == 1.0) then
          ! Solve for the suspension flux.
          call suspension_init(Qs_u,Qs_v)
        end if
        
    end subroutine SNOWTRAN3D_susp_start
    
    subroutine SNOWTRAN3D_salt_start(Qs_u,Qs_v)
        implicit none
        
        real, intent(inout) :: &
         Qs_u(Nx,Ny),          &! x component of either Qsalt or Qsusp (kg/m/s)
         Qs_v(Nx,Ny)            ! y component of either Qsalt or Qsusp (kg/m/s)

        !Clear trans arrays
        Qs_u = 0.0
        dSWE_s_u = 0.0
        dSWE_s_u_gain = 0.0
        dSWE_s_u_loss = 0.0
        Qs_v = 0.0
        dSWE_s_v = 0.0
        dSWE_s_v_gain = 0.0
        dSWE_s_v_loss = 0.0
        
        dSWE_salt = 0.0
        Qsalt = 0.0
    
        call saltation_init(Qs_u,Qs_v)
    
    end subroutine SNOWTRAN3D_salt_start

    subroutine SNOWTRAN3D_susp_end()
    
      implicit none

      real                :: &
        dSWE_s(Nx,Ny)    ! Net mass change to sum
    
      ! Sum new depth from the mass change arrays (stored as module variables)
      call sumnewdepth(dSWE_s)
      dSWE_susp = dSWE_s
    
    end subroutine SNOWTRAN3D_susp_end
    
    subroutine SNOWTRAN3D_salt_end(Qs_u,Qs_v)
      implicit none

      real, intent(inout) :: &
       Qs_u(Nx,Ny),          &! x component of either Qsalt or Qsusp (kg/m/s)
       Qs_v(Nx,Ny)            ! y component of either Qsalt or Qsusp (kg/m/s)

      real                :: &
        dSWE_s(Nx,Ny)    ! Net mass change to sum
    
      ! Solve for the saltation flux.
      call saltation_accum(Qs_u,Qs_v)

      ! Sum new depth from the mass change arrays (stored as module variables)
      call sumnewdepth(dSWE_s)
      dSWE_salt = dSWE_s
      
    end subroutine SNOWTRAN3D_salt_end


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine suspension_init(Qsusp_u,Qsusp_v)

    use CONSTANTS, only: &
      vkman               ! Von Karman constant

    use DRIVING, only: &
      Ta,                &! Air temperature (K)
      RH                  ! Relative humidity (%)

    use LANDUSE, only: &
      dem                 ! Terrain elevation (m)

    use CONSTANTS_SNOWTRAN3D, only: &
      Up_const,          &! Constant coefficient for calculation of U_p
      dz_susp,           &! dz in suspension layer
      ztop_susp,         &! Height of the top of suspension layer (m)
      fall_vel,          &! Particle-settling velocity, s in L&S 1998 eq. 12 (m/s)
      Ur_const            ! Constant coefficient beta in L&S 1998, eq. 13

    implicit none

    real, intent(inout) :: &
      Qsusp_u(Nx,Ny),    &! x component of suspension flux (kg/m/s)
      Qsusp_v(Nx,Ny)      ! y component of suspension flux (kg/m/s)

    real                :: &
      conc_salt(Nx,Ny)    ! Saltation-layer reference-level mass concentration (kg/m^3)


    integer :: &
      i,j,               &! Point counters
      nzsteps,           &! Number of vertical steps
      iz                  ! Vertical steps counter

    real :: &
      Qsusp,             &! Suspension flux (kg/m/s)
      conc,              &! Concentration of the suspended snow at height z (kg/m^3)
      Utau_fallvel,      &! Auxiliary variable Utau/fall_vel
      prd,               &! Auxiliary variable for calculations
      U_p,               &! Horizontal particle velocity within the saltation layer (m/s)
      U_r,               &! Wind speed at height h_star (m/s)
      phistar_Cr,        &! Left member of L&S 1998 eq. 13
      V_susp,            &! Sublimation loss rate coefficient in the suspension layer (s^-1)
      V_salt,            &! Sublimation loss rate coefficient in the saltation layer (s^-1)
      z                   ! Height (m)

    ! Compute the mass concentration of suspended snow according to
    ! Kind (1992).

    do i = 1, Nx
      do j = 1, Ny
      
        if (isnan(dem(i,j))) goto 6 ! Exclude points outside of the domain
        
        Qsusp = 0.0
        
        if (Qsalt(i,j) > epsilon(Qsalt)) then
          Utau_fallvel = Utau(i,j) / fall_vel
          ! LQ: the present subroutine (suspension) is only called in the case there is saltation (bs_flag = 1)
          ! in which case (see third case of solveUtau): h* = (h_const/C_z) z0 = 13.3 z0
          ! So no need to check h*, the following log is always positive
          U_r = Utau(i,j)/vkman * log(h_star(i,j)/z_0(i,j))
          phistar_Cr = Utau(i,j)/U_r * Ur_const
          prd = phistar_Cr * Utau_fallvel
          U_p = Up_const * Utau_t(i,j)

          ! Compute the concentration in the saltation layer (kg/m^3).
          conc_salt(i,j) = Qsalt(i,j) / (h_star(i,j) * U_p)

          nzsteps = int((ztop_susp - h_star(i,j)) / dz_susp)

          Qsubl(i,j) = 0.0

          do iz = 1, nzsteps
            z = h_star(i,j) + 0.5 * dz_susp + real(iz - 1) * dz_susp

            ! Compute the concentration of the suspended snow at height z.
            conc = conc_salt(i,j) * ((prd + 1.0) * &
                   (z/h_star(i,j))**((-fall_vel)/(vkman*Utau(i,j))) - &
                   prd)
            conc = max(conc,0.0)

            ! Only do the integration if the concentration is non-zero.
            if (conc > epsilon(conc)) then

              ! Compute the sublimation due to suspension.
              call getsublim(z,RH(i,j),Ta(i,j),Utau(i,j), &
                             z_0(i,j),V_susp,V_salt,Utau_t(i,j),1.0)

              ! Perform the quadrature (summation), without the constants.
              if (z == z_0(i,j)) z = 1.2 * z_0(i,j)
              Qsusp      = Qsusp + conc * log(z/z_0(i,j)) * dz_susp
              Qsubl(i,j) = Qsubl(i,j) + conc * V_susp * dz_susp

            end if

          end do

          ! Finish the quadratures.
          ! Include the constants for Qsusp.
          Qsusp = Utau(i,j) / vkman * Qsusp

          ! Include the sublimation contribution due to saltation.
          z = h_star(i,j) / 2.0
          call getsublim(z,RH(i,j),Ta(i,j),Utau(i,j), &
                         z_0(i,j),V_susp,V_salt,Utau_t(i,j),0.0)

          Qsubl(i,j) = Qsubl(i,j) + V_salt * conc_salt(i,j) * h_star(i,j)

        end if

        ! Separate the east-west and the north-south suspended transport
        ! components; the vector sum should equal Qsusp.
        Qsusp_u(i,j) = Qsusp * abs(uwind(i,j)) / &
                       sqrt(uwind(i,j)**2 + vwind(i,j)**2)
        Qsusp_v(i,j) = Qsusp * abs(vwind(i,j)) / &
                       sqrt(uwind(i,j)**2 + vwind(i,j)**2)

        6 continue  ! Exclude points outside of the domain

      end do
    end do

    end subroutine suspension_init



    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine saltation_init(Qsalt_u, Qsalt_v)

    use CONSTANTS, only: &
      grav,                 &! Acceleration due to gravity (m/s^2)
      rho_air                ! Density of air (kg/m^3)

    use LANDUSE, only: &
      dem                    ! Terrain elevation (m)

    use PARAM_SNOWTRAN3D, only: &
      bc_flag                ! Boundary condition flag

    implicit none
    real, intent(inout) :: &
      Qsalt_u(Nx,Ny),      &
      Qsalt_v(Nx,Ny)

    integer :: &
      i,j,k,                &! Point counters
      istart,iend,          &! Point counters boundaries
      jstart,jend            ! Point counters boundaries

    real :: &
      Qsalt_max(Nx,Ny)       ! Maximum possible saltation flux (kg/m/s)

    ! Compute the maximum possible saltation flux, assuming that
    ! an abundance of snow is available at the surface.
    do i = 1, Nx
      do j = 1, Ny

        if (isnan(dem(i,j))) goto 8 ! Exclude points outside of the domain

        ! For a given wind speed, find Qsalt_max.
        Qsalt_max(i,j) = 0.68 * rho_air / grav * &
                         Utau_t(i,j) / Utau(i,j) * (Utau(i,j)**2 - Utau_t(i,j)**2)
        Qsalt_max(i,j) = max(Qsalt_max(i,j),0.0)

        ! Now weight the max saltation flux for the u and v wind
        ! components, where the vector sum should equal Qsalt_max.
        Qsalt_maxu(i,j) = Qsalt_max(i,j) * abs(uwind(i,j)) / &
                          sqrt(uwind(i,j)**2 + vwind(i,j)**2)
        Qsalt_maxv(i,j) = Qsalt_max(i,j) * abs(vwind(i,j)) / &
                          sqrt(uwind(i,j)**2 + vwind(i,j)**2)

        8 continue  ! Exclude points outside of the domain

      end do
    end do

    ! Define an upwind boundary condition.  If bc_flag = 1.0 then it is
    ! assumed that the inflow saltation flux has reached steady state.
    ! If bc_flag = 0.0 then the saltation flux is assumed to be zero.
    ! The boundary condition is implemented by initializing the arrays
    ! to Qsalt_max, and since upwind boundaries are not called in
    ! the Qsalt computation, they stay in effect for the future 
    ! accumulation/erosion computation.
    if (bc_flag == 0.0) then
      do i = 1, Nx
        do j = 1, Ny

          if (isnan(dem(i,j))) goto 9 ! Exclude points outside of the domain

          ! Zero incoming flux at the boundaries.
          Qsalt_u(i,j) = 0.0
          Qsalt_v(i,j) = 0.0

          9 continue  ! Exclude points outside of the domain

        end do
      end do
    else if (bc_flag == 1.0) then
      do i = 1, Nx
        do j = 1, Ny

          if (isnan(dem(i,j))) goto 10 ! Exclude points outside of the domain

          ! Steady-state (maximum) incoming flux at the boundaries.
          Qsalt_u(i,j) = Qsalt_maxu(i,j)
          Qsalt_v(i,j) = Qsalt_maxv(i,j)

          10 continue  ! Exclude points outside of the domain

        end do
      end do
    end if

    end subroutine saltation_init


    subroutine saltation_accum(Qsalt_u,Qsalt_v)

    use LANDUSE, only: &
      dem                    ! Terrain elevation (m)
      
    implicit none

    real, intent(inout) :: &
      Qsalt_u(Nx,Ny),      &
      Qsalt_v(Nx,Ny)      

    integer :: &
      i,j,k                  ! Point counters

    ! Adjust Qsalt to account for the availablity of snow for transport;
    ! taking into consideration whether there is snow on the ground,
    ! the holding depth of the vegetation, etc..
    do i = 1, Nx
      do j = 1, Ny

        if (isnan(dem(i,j))) goto 12 ! Exclude points outside of the domain

        ! This statement below has been handeled in the SNOWTRAN3D_fluxes function now
        !if ((snowthickness(i,j) <= vegsnowd_xy(i,j)) .or. (Ds_soft(i,j) <= epsilon(Ds_soft))) then
        !  Qsalt_u(i,j) = 0.0
        !  Qsalt_v(i,j) = 0.0
        !end if
        
        Qsalt(i,j) = Qsalt_u(i,j) + Qsalt_v(i,j)

        12 continue  ! Exclude points outside of the domain

      end do
    end do

    end subroutine saltation_accum
    
    
    ! This function essentially integrates calc_saltation_fluxes and getnewdepth from Louis' code
    ! Both have to be done together here, since getnewdepth can adjust the saltation fluxes according
    ! To the ammount of snow present on the ground, thus breaking parallelisim (sp?). 
    !
    ! The function updates Qsalt_u/v, and updates the change in mass arrays at the same time
    
    subroutine SNOWTRAN3D_salt(Qsalt_u,Qsalt_v)
    
        use DRIVING, only: &
          dt                     ! Timestep (s)

        use PARAM_SNOWTRAN3D, only: &
          blowby                 ! Fraction of the saltation flux transferred downwind
        use CONSTANTS_SNOWTRAN3D, only: &
          fetch,                &! Equilibrium fetch distance (m)
          xmu                    ! Scaling constant for non-equilibrium saltation transport

        use PARAMMAPS, only: &
          vegsnowd_xy            ! Vegetation snow holding capacity (m)
          
        use STATE_VARIABLES, only: &
          Sice,                  &! Ice content of snow layers (kg/m^2)
          Sliq,                  &! Liquid content of snow layers (kg/m^2)
          fsnow                  ! Snow cover fraction 

        implicit none
        
        real, intent(inout) :: &
          Qsalt_u(Nx,Ny), &
          Qsalt_v(Nx,Ny)
        
        integer :: &
          i,j,k,                &! Point counters
          istart,iend,          &! Point counters boundaries
          jstart,jend            ! Point counters boundaries

        real :: &
          Ds_hard,              &
          dh_s_loss,            &!Holder variable for calculating loss of snow height
          snowdmin,             &
          swe_loc,              &! SWE in the snow covered part of the pixel (kg/m^2)
          dUtau,                &! Utau difference (m/s)
          scale_EW,             &! Scaling coefficient for Eqn. 9 in L&S 1998
          scale_NS               ! Scaling coefficient for Eqn. 9 in L&S 1998

        ! Define the scaling coefficients for Eqn. 9 in L&S 1998. Don't
        ! let them be greater than 1.0 or you will make more snow than
        ! there was before.
        scale_EW =  xmu * delta_WE / fetch
        scale_EW = min(1.0,scale_EW)
        scale_NS =  xmu * delta_SN / fetch
        scale_NS = min(1.0,scale_NS)

        if (any(abs(Qsalt_u)>0.0) .or. any(abs(Qsalt_v)>0)) bs_flag=1.0
        
        if (bs_flag==1.0 ) then
            ! Consider WESTERLY winds.
            do i = 1, Nx
              do k = 1, index_uw(i,1)
                jstart = index_uw(i,k*2)+1
                jend = index_uw(i,k*2+1)
                do j = jstart, jend
                  if ((snowthickness(i,j) <= vegsnowd_xy(i,j)) .or. (Ds_soft(i,j) <= epsilon(Ds_soft))) then
                      Qsalt_u(i,j) = 0.0
                      goto 25
                  endif
                  
                  Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
                  snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
                  if (.not.(snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow))) then
                      Qsalt_u(i,j) = 0.0
                      goto 25
                  endif

                  dUtau = Utau(i,j) - Utau(i,j-1)
                  if (dUtau >= epsilon(dUtau)) then
                    Qsalt_u(i,j) = Qsalt_u(i,j-1) + scale_EW * &
                                   (Qsalt_maxu(i,j) - Qsalt_u(i,j-1))
                  else
                    if (Qsalt_u(i,j-1) < Qsalt_maxu(i,j)) then
                      Qsalt_u(i,j) = Qsalt_u(i,j-1)
                    else
                      Qsalt_u(i,j) = max(blowby*Qsalt_u(i,j-1),Qsalt_maxu(i,j))
                    end if
                  end if
                  
                  25 continue
                  
                  swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
                  dSWE_s_u_loss(i,j) = dt * Qsalt_u(i,j) * fsnow(i,j) / delta_WE
                  dSWE_s_u_gain(i,j) = dt * Qsalt_u(i,j-1) * fsnow(i,j-1) / delta_WE
                  dSWE_s_u_loss(i,j) = min(dSWE_s_u_loss(i,j),swe_loc) ! No need to adjust Qsalt_u here because if thresholded, it will be done in the next if loop anyway
                  if (dSWE_s_u_loss(i,j) > epsilon(dSWE_s_u_loss)) then
                    call HS_FROM_SWE(dSWE_s_u_loss(i,j),dh_s_loss,i,j)
                  else
                    dSWE_s_u_loss(i,j) = 0.0
                    dh_s_loss = 0.0
                  end if
                  dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
                  
                  if (Qsalt_u(i,j)==0.0) cycle
                  
                  ! Make adjustments for the case where there is no snow available
                  ! on the ground (or captured within the vegetation) to be
                  ! eroded.
                  if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
                    dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
                    if (dh_s_loss > epsilon(dh_s_loss)) then
                      call SWE_FROM_HS(dh_s_loss,dSWE_s_u_loss(i,j),i,j)
                    else
                      dSWE_s_u_loss(i,j) = 0.0
                    end if
                    dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
                    Qsalt_u(i,j) = Qsalt_u(i,j-1) - dSWE_s_u(i,j) * delta_WE / dt / fsnow(i,j)
                  end if
                  
                  dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
                end do
              end do
            end do
            ! Consider EASTERLY winds.
            do i = 1, Nx
              do k = 1, index_ue(i,1)
                jend = index_ue(i,k*2)
                jstart = index_ue(i,k*2+1)-1
                do j = jstart, jend,-1
                  if ((snowthickness(i,j) <= vegsnowd_xy(i,j)) .or. (Ds_soft(i,j) <= epsilon(Ds_soft))) then
                      Qsalt_u(i,j) = 0.0
                      goto 26
                  endif
                  
                  Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
                  snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
                  if (.not.(snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow))) then
                      Qsalt_u(i,j) = 0.0
                      goto 26
                  endif
                  
                  dUtau = Utau(i,j) - Utau(i,j+1)
                  if (dUtau >= epsilon(dUtau)) then
                    Qsalt_u(i,j) = Qsalt_u(i,j+1) + scale_EW * &
                                   (Qsalt_maxu(i,j) - Qsalt_u(i,j+1))
                  else
                    if (Qsalt_u(i,j+1) < Qsalt_maxu(i,j)) then
                      Qsalt_u(i,j) = Qsalt_u(i,j+1)
                    else
                      Qsalt_u(i,j) = max(blowby*Qsalt_u(i,j+1),Qsalt_maxu(i,j))
                    end if
                  end if
                  
                  26 continue
                  
                  swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
                  dSWE_s_u_loss(i,j) = dt * Qsalt_u(i,j) * fsnow(i,j) / delta_WE
                  dSWE_s_u_gain(i,j) = dt * Qsalt_u(i,j+1) * fsnow(i,j+1) / delta_WE
                  dSWE_s_u_loss(i,j) = min(dSWE_s_u_loss(i,j),swe_loc) ! No need to adjust Qsalt_u here because if thresholded, it will be done in the next if loop anyway
                  if (dSWE_s_u_loss(i,j) > epsilon(dSWE_s_u_loss)) then
                    call HS_FROM_SWE(dSWE_s_u_loss(i,j),dh_s_loss,i,j)
                  else
                    dSWE_s_u_loss(i,j) = 0.0
                    dh_s_loss = 0.0
                  end if
                  dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
                  
                  if (Qsalt_u(i,j)==0.0) cycle
                  
                  ! Make adjustments for the case where there is no snow available
                  ! on the ground (or captured within the vegetation) to be
                  ! eroded.
                  if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
                    dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
                    if (dh_s_loss > epsilon(dh_s_loss)) then
                      call SWE_FROM_HS(dh_s_loss,dSWE_s_u_loss(i,j),i,j)
                    else
                      dSWE_s_u_loss(i,j) = 0.0
                    end if
                    dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
                    Qsalt_u(i,j) = Qsalt_u(i,j+1) - dSWE_s_u(i,j) * delta_WE / dt / fsnow(i,j)
                  end if
                  
                end do
              end do
            end do
            ! Consider SOUTHERLY winds.
            do j = 1, Ny
              do k = 1, index_vs(j,1)
                istart = index_vs(j,k*2)+1
                iend = index_vs(j,k*2+1)
                do i = istart, iend
                  if ((snowthickness(i,j) <= vegsnowd_xy(i,j)) .or. (Ds_soft(i,j) <= epsilon(Ds_soft))) then
                      Qsalt_v(i,j) = 0.0
                      goto 27
                  endif
                  
                  Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
                  snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
                  if (.not.(snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow))) then
                      Qsalt_v(i,j) = 0.0
                      goto 27
                  endif
                  
                  dUtau = Utau(i,j) - Utau(i-1,j)
                  if (dUtau >= epsilon(dUtau)) then
                    Qsalt_v(i,j) = Qsalt_v(i-1,j) + scale_NS * &
                                   (Qsalt_maxv(i,j) - Qsalt_v(i-1,j))
                  else
                    if (Qsalt_v(i-1,j) < Qsalt_maxv(i,j)) then
                      Qsalt_v(i,j) = Qsalt_v(i-1,j)
                    else
                      Qsalt_v(i,j) = max(blowby*Qsalt_v(i-1,j),Qsalt_maxv(i,j))
                    end if
                  end if
                  
                  27 continue
                                    
                  swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
                  dSWE_s_v_loss(i,j) = dt * Qsalt_v(i,j) * fsnow(i,j) / delta_SN
                  dSWE_s_v_gain(i,j) = dt * Qsalt_v(i-1,j) * fsnow(i-1,j) / delta_SN
                  dSWE_s_v_loss(i,j) = min(dSWE_s_v_loss(i,j),swe_loc) ! No need to adjust Qsalt_v here because if thresholded, it will be done in the next if loop anyway
                  if (dSWE_s_v_loss(i,j) > epsilon(dSWE_s_v_loss)) then
                    call HS_FROM_SWE(dSWE_s_v_loss(i,j),dh_s_loss,i,j)
                  else
                    dSWE_s_v_loss(i,j) = 0.0
                    dh_s_loss = 0.0
                  end if
                  dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
                  
                  if (Qsalt_v(i,j)==0.0) cycle
                  
                  ! Make adjustments for the case where there is no snow available
                  ! on the ground (or captured within the vegetation) to be
                  ! eroded.
                  if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
                    dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
                    if (dh_s_loss > epsilon(dh_s_loss)) then
                      call SWE_FROM_HS(dh_s_loss,dSWE_s_v_loss(i,j),i,j)
                    else
                      dSWE_s_v_loss(i,j) = 0.0
                    end if
                    dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
                    Qsalt_v(i,j) = Qsalt_v(i-1,j) - dSWE_s_v(i,j) * delta_SN / dt / fsnow(i,j)
                  end if
                end do
              end do
            end do
            ! Consider NORTHERLY winds.
            do j = 1, Ny
              do k = 1, index_vn(j,1)
                iend = index_vn(j,k*2)
                istart = index_vn(j,k*2+1)-1
                do i = istart, iend,-1
                  if ((snowthickness(i,j) <= vegsnowd_xy(i,j)) .or. (Ds_soft(i,j) <= epsilon(Ds_soft))) then
                      Qsalt_v(i,j) = 0.0
                      goto 28
                  endif
                  
                  Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
                  snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
                  if (.not.(snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow))) then
                      Qsalt_v(i,j) = 0.0
                      goto 28
                  endif
                  
                  dUtau = Utau(i,j) - Utau(i+1,j)
                  if (dUtau >= epsilon(dUtau)) then
                    Qsalt_v(i,j) = Qsalt_v(i+1,j) + scale_NS * &
                                   (Qsalt_maxv(i,j) - Qsalt_v(i+1,j))
                  else
            !        Qsalt_v(i,j) = min(Qsalt_v(i+1,j),Qsalt_maxv(i,j))
                    if (Qsalt_v(i+1,j) < Qsalt_maxv(i,j)) then
                      Qsalt_v(i,j) = Qsalt_v(i+1,j)
                    else
                      Qsalt_v(i,j) = max(blowby*Qsalt_v(i+1,j),Qsalt_maxv(i,j))
                    end if
                  end if
                  
                  28 continue
                  
                  swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
                  dSWE_s_v_loss(i,j) = dt * Qsalt_v(i,j) * fsnow(i,j) / delta_SN
                  dSWE_s_v_gain(i,j) = dt * Qsalt_v(i+1,j) * fsnow(i+1,j) / delta_SN
                  dSWE_s_v_loss(i,j) = min(dSWE_s_v_loss(i,j),swe_loc) ! No need to adjust Qsalt_v here because if thresholded, it will be done in the next if loop anyway
                  if (dSWE_s_v_loss(i,j) > epsilon(dSWE_s_v_loss)) then
                    call HS_FROM_SWE(dSWE_s_v_loss(i,j),dh_s_loss,i,j)
                  else
                    dSWE_s_v_loss(i,j) = 0.0
                    dh_s_loss = 0.0
                  end if
                  dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
                  
                  if (Qsalt_v(i,j)==0.0) cycle
                  
                  ! Make adjustments for the case where there is no snow available
                  ! on the ground (or captured within the vegetation) to be
                  ! eroded.
                  if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
                    dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
                    if (dh_s_loss > epsilon(dh_s_loss)) then
                      call SWE_FROM_HS(dh_s_loss,dSWE_s_v_loss(i,j),i,j)
                    else
                      dSWE_s_v_loss(i,j) = 0.0
                    end if
                    dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
                    Qsalt_v(i,j) = Qsalt_v(i+1,j) - dSWE_s_v(i,j) * delta_SN / dt / fsnow(i,j)
                  end if
                end do
              end do
            end do
        endif
        
    end subroutine SNOWTRAN3D_salt


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine solveUtau(veg_z0)

    use CONSTANTS, only: &
      grav,                 &! Acceleration due to gravity (m/s^2)
      vkman                  ! Von Karman constant

    use DRIVING, only: &
      Ua,                   &! Wind speed (m/s)
      zU                     ! Height of the wind speed measurement (m)

    use PARAMMAPS, only: &
      vegsnowd_xy,          &! Vegetation snow holding capacity (m)
      z0_snow                ! Roughness length of snow (m)

    use LANDUSE, only: &
      dem                    ! Terrain elevation (m)

    use CONSTANTS_SNOWTRAN3D, only: &
      C_z,                  &! Coefficient 0.12 in Liston and Sturm (1998) eq. 5 p. 500
      h_const                ! Coefficient 1.6 in Liston and Sturm (1998) eq. 14 p. 501

    implicit none

    real, intent(in) :: &
      veg_z0(Nx,Ny)          ! Vegetation roughness length (m)

    integer :: &
      i,j                    ! Point counters

    real :: &
      threshold,            &! Threshold for u* (m/s)
      threshold_flag,       &! Flag if u* is above threshold
      guess,                &! Initial guess for Utau
      sfrac,                &! Depth-fraction of vegetation covered by snow
      Utautmp,              &! Temporary Utau variable (m/s)
      windtmp,              &! Temporary wind speed variable (m/s)
      wind_max,             &! Maximum wind speed (m/s)
      z_0_tmp                ! Temporary z_0 variable (m)

    ! Initially set the blowing snow flag to no blowing snow
    ! (bs_flag = 0.0).  Then, if snow is found to blow in any
    ! domain grid cell, set the flag to on (bs_flag = 1.0).
    bs_flag = 0.0

    ! Build the Utau array.
    guess = 0.1
    do i = 1, Nx
      do j = 1, Ny

        if (isnan(dem(i,j))) goto 13 ! Exclude points outside of the domain

        ! Determine whether snow is saltating (this influences how Utau
        ! and z_0 are computed).
        if (snowthickness(i,j) <= vegsnowd_xy(i,j)) then

          ! Saltation will not occur.
          sfrac = snowthickness(i,j) / max(vegsnowd_xy(i,j),veg_z0(i,j)) ! Eq. 3, LS 1998
          z_0(i,j) = sfrac * z0_snow(i,j) + (1.0 - sfrac) * veg_z0(i,j) ! Eq. 4, LS 1998
          z_0_tmp = min(0.25*zU,z_0(i,j))
          Utau(i,j) = Ua(i,j) * vkman / log(zU/z_0_tmp)
          h_star(i,j) = z_0(i,j) * h_const / C_z

        else if (Ds_soft(i,j) <= epsilon(Ds_soft)) then

          ! Saltation will not occur.
          z_0(i,j) = z0_snow(i,j)
          Utau(i,j) = Ua(i,j) * vkman / log(zU/z_0(i,j))
          h_star(i,j) = z_0(i,j)

        else

          ! Saltation may occur.  Test for that possibility by assuming that
          ! saltation is present, solving for Utau and z_0, and comparing
          ! whether Utau exceeds Utau_t.  If it does not, set z_0 to that
          ! of snow and recompute Utau.

          ! To help insure that the iteration converges, set the minimum
          ! wind speed to be 1.0 m/s, and the maximum wind speed to be
          ! 30 m/s at 10-m height.
          windtmp = max(1.0,Ua(i,j))
          wind_max = 30.0 * log(zU/z0_snow(i,j))/log(10.0/z0_snow(i,j))
          windtmp = min(windtmp,wind_max) 

          ! For u* over 0.6, use the relation z0 = 0.00734 u* - 0.0022,
          ! instead of Equation (5) in Liston and Sturm (1998).  Note that
          ! for windspeeds greater than about 35 m/s this will have to be
          ! modified for the solution algorithm to converge (because the
          ! roughness length will start to be higher than the obs height!).
          threshold = 0.6/vkman * log(zU/0.0022)
          if (windtmp <= threshold) then
            threshold_flag = 1.0
          else
            threshold_flag = 2.0
          end if

          call solve1(Utautmp,guess,windtmp, &
                      threshold_flag)

          if (Utautmp > Utau_t(i,j)) then

            ! We have saltation.
            Utau(i,j) = Utautmp
            z_0(i,j) = C_z * Utau(i,j)**2 / (2.0 * grav)
            h_star(i,j) = h_const * Utau(i,j)**2 / (2.0 * grav)
            bs_flag = 1.0

          else

            ! We do not have saltation, but the vegetation is covered by snow.
            ! Because we have determined that we do not have saltation, make
            ! sure Utau does not exceed Utau_t.
            z_0(i,j) = z0_snow(i,j)
            Utau(i,j) = Ua(i,j) * vkman / log(zU/z_0(i,j))
            Utau(i,j) = min(Utau(i,j),Utau_t(i,j))
            h_star(i,j) = z_0(i,j) * h_const / C_z

          end if
        end if

        13 continue  ! Exclude points outside of the domain

      end do
    end do

    end subroutine solveUtau

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine solve1(xnew,guess,windtmp,threshold_flag)

    use CONSTANTS, only: &
      grav,              &! Acceleration due to gravity (m/s^2)
      vkman               ! Von Karman constant

    use DRIVING, only: &
      zU                  ! Height of the wind speed measurement (m)

    use CONSTANTS_SNOWTRAN3D, only: &
      C_z                 ! Coefficient 0.12 in Liston and Sturm (1998) eq. 5 p. 500

    implicit none

    real, intent(in) :: &
      guess,             &! Initial guess for Utau (m/s)
      windtmp,           &! Wind speed (m/s)
      threshold_flag      ! Flag if u* is above threshold

    real, intent(inout) :: &  
      xnew                ! Solution for Utau (m/s)

    integer :: &
      i,                 &! Point counter
      maxiter             ! Number of iterations

    real :: &
      tol,               &! Convergence threshold
      old,               &! Temporary xnew
      fprime,            &! Temporary function 1
      funct               ! Temporary function 2

    tol = 1.0e-3
    maxiter = 20
    old = guess

    if (threshold_flag == 1.0) then

      do i = 1, maxiter
        fprime = - 1.0 + 2.0 / old * windtmp * vkman * &
                (log(zU) - log(C_z/(2.0*grav)) - 2.0*log(old))**(-2)
        funct = - old + windtmp * vkman * &
               (log(zU) - log(C_z/(2.0*grav)) - 2.0*log(old))**(-1)
        xnew = old - funct/fprime
        if (abs(xnew - old) < tol) return
        old = xnew
      end do

    else if (threshold_flag == 2.0) then

      old = 0.6
      do i = 1, maxiter
        fprime = - 1.0 + windtmp * vkman * 0.00734 / (0.00734 * old - 0.0022) * &
                (log(zU) - log(0.00734 * old - 0.0022))**(-2)
        funct = - old + windtmp * vkman * &
               (log(zU) - log(0.00734 * old - 0.0022))**(-1)
        xnew = old - funct/fprime
        if (abs(xnew - old) < tol) return
        old = xnew
      end do

    end if

    write(*,*) 'max iteration exceeded when solving for Utau, Utau=',old

    end subroutine solve1

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine getsublim(z,RH,Ta,Utau,z_0,V_susp,V_salt,Utau_t,flag)

    use CONSTANTS, only: &
      hcon_air,          &! Thermal conductivity of air (W/m/K)
      Ls,                &! Latent heat of sublimation (J/kg)
      pi,                &! pi
      Rair,              &! Gas constant for air (J/K/kg)
      Runi,              &! Universal gas constant (J/kmol/K)
      rho_ice,           &! Density of ice (kg/m^3)
      Tm,                &! Melting point (K)
      vkman,             &! Von Karman constant
      xM,                &! Molecular weight of water (kg/kmol)
      visc_air            ! Kinematic viscosity of air (m^2/s)

    use DRIVING, only: &
      zRH                 ! Relative humidity measurement height (m)

    implicit none

    real, intent(in) :: &
      z,                 &! Height (m)
      RH,                &! Relative humidity (%)
      Ta,                &! Air temperature (K)
      Utau_t,          &! Threshold friction velocity (m/s)
      Utau,            &! Friction velocity (m/s)
      flag,              &! 1: sublimation due to suspension, 0: sublimation due to saltation
      z_0                 ! Surface roughness length (m)

    real, intent(out) :: &
      V_susp,            &! Sublimation loss rate coefficient in the suspension layer (s^-1)
      V_salt              ! Sublimation loss rate coefficient in the saltation layer (s^-1)

    real :: &
      D,                 &! Diffusivity of water vapor in the atmosphere (m^2/s)
      rho_sat,           &! Saturation density of water vapour (kg/m^3)
      rh_offset,         &! Relative humidity offset (fraction 0->1)
      sigma,             &! Atmospheric undersaturation of water vapour with respect to ice at height z
      alpha,             &! Coefficient alpha defined in L&S (1998), eq. A-5 p. 515 
      rbar_r,            &! Mean radius of snow particles at height z (m)
      xmbar,             &! Mean particle mass at height z (m)
      rbar,              &! Radius of a snow particle of mean particle mass xmbar at height z (m)
      u_z,               &! Wind speed at height z (m)
      x_r,               &! Fluctuating velocity component (m/s), defined in L&S (1998), eq. A-18 p. 516
      wbar,              &! Mean terminal fall velocity of suspended snow (m/s), L&S (1998), eq. A-17 p. 516
      V_r,               &! Ventilation velocity for turbulent suspension (m/s)
      V_rsalt,           &! Ventilation velocity for saltation (m/s)
      xN_r,              &! Particle Reynolds number Re
      xNu,               &! Nusselt number
      xSh,               &! Sherwood number
      tmp1,              &! Auxiliary variable 1
      tmp2,              &! Auxiliary variable 2
      top,               &! Top of eq. A-6, p. 516, L&S (1998)
      bottom              ! Bottom of eq. A-6, p. 516, L&S (1998)

    D = 2.06e-5 * (Ta/273.)**(1.75)
    ! rho_sat = 0.622 * 10.0**(11.40 - 2353./Ta) / (Rair * Ta)
    rho_sat = 0.622 / (Rair * Ta) * 610.78 * exp(21.875 * (Ta - Tm) / (Ta - 7.66))

    ! Assume that the rh varies according to a modification to 
    ! Pomeroy's humidity variation with height equation.
    rh_offset = 1.0 - 0.027 * log(zRH)
    sigma = (0.01 * RH - 1.0) * (rh_offset + 0.027 * log(z))
    sigma = min(0.0,sigma)
    sigma = max(-1.0,sigma)

    alpha = 4.08 + 12.6 * z
    rbar_r = 4.6e-5 * z**(-0.258)
    xmbar = 4.0/3.0 * pi * rho_ice * rbar_r**3 * (1.0 + 3.0/alpha + 2.0/alpha**2)
    rbar = ((3.0 * xmbar) / (4.0 * pi * rho_ice))**(0.33)
    u_z = Utau/vkman * log(z/z_0)
    x_r = 0.005 * u_z**(1.36)
    wbar = 1.1e7 * rbar**(1.8)

    if (flag == 1.0) then

      ! Compute the sublimation loss rate coefficient for the suspension
      ! layer.
      V_r = wbar + 3.0 * x_r * cos(pi/4.0)
      xN_r = 2.0 * rbar * V_r / visc_air
      xNu = 1.79 + 0.606 * xN_r**(0.5)
      xSh = xNu
      tmp1 = (Ls * xM)/(Runi * Ta) - 1.0
      tmp2 = hcon_air * Ta * xNu
      top = 2.0 * pi * rbar * sigma
      bottom = Ls/tmp2 * tmp1 + 1.0/(D * rho_sat * xSh)
      V_susp = (top/bottom)/xmbar
      V_salt = 0.0

    else if (flag == 0.0) then

      ! Compute the sublimation loss rate coefficient for the saltation
      ! layer.
      V_rsalt = 0.68 * Utau + 2.3 * Utau_t
      xN_r = 2.0 * rbar * V_rsalt / visc_air
      xNu = 1.79 + 0.606 * xN_r**(0.5)
      xSh = xNu
      tmp1 = (Ls * xM)/(Runi * Ta) - 1.0
      tmp2 = hcon_air * Ta * xNu
      top = 2.0 * pi * rbar * sigma
      bottom = Ls/tmp2 * tmp1 + 1.0/(D * rho_sat * xSh)
      V_salt = (top/bottom)/xmbar
      V_susp = 0.0

    end if

    end subroutine getsublim

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine getdirection()

    use LANDUSE, only: &
      dem                 ! Terrain elevation (m)

    implicit none

    integer :: &
      i,j,               &! Point counters
      npairs              ! ?

    real :: &
      sign1,sign2         ! Sign indicators of wind

    ! Index whether the winds are blowing east or west.  The first
    ! column of the index array is the number of pairs of begining
    ! and ending array index of blocks of wind running in the same
    ! direction.

    ! Sweep looking for WESTERLY winds, looking for positive numbers.
    do i = 1, Nx

      if (uwind(i,1) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 > 0.0) then
        npairs = 1
        index_uw(i,2) =  1
      else
        npairs = 0
      end if

      do j = 2, Ny

        if (isnan(dem(i,j))) goto 16 ! Exclude points outside of the domain

        if (uwind(i,j-1) <= 0.0) then
          sign1 = -1.0
        else
          sign1 = 1.0
        end if
        if (uwind(i,j) <= 0.0) then
          sign2 = -1.0
        else
          sign2 = 1.0
        end if

        if (sign2 /= sign1) then
          ! We have a sign change.
          if (sign2 > 0.0) then
            ! We have gone from negative to positive, indicating the start
            ! of a new positive group.
            npairs = npairs + 1
            index_uw(i,npairs*2) = j
          else
            ! We have gone from positive to negative, indicating the end of
            ! the group.
            index_uw(i,npairs*2+1) = j - 1
          end if
        end if

        16 continue  ! Exclude points outside of the domain

      end do

      if (uwind(i,Ny) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 > 0.0) then
        index_uw(i,npairs*2+1) = Ny
      end if
      index_uw(i,1) = npairs
    end do

    ! Sweep looking for EASTERLY winds, looking for negative numbers.
    do i = 1, Nx

      if (uwind(i,1) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 < 0.0) then
        npairs = 1
        index_ue(i,2) = 1
      else
        npairs = 0
      end if

      do j = 2, Ny

        if (isnan(dem(i,j))) goto 17 ! Exclude points outside of the domain

        if (uwind(i,j-1) <= 0.0) then
          sign1 = -1.0
        else
          sign1 = 1.0
        end if
        if (uwind(i,j) <= 0.0) then
          sign2 = -1.0
        else
          sign2 = 1.0
        end if

        if (sign2 /= sign1) then
          ! We have a sign change.
          if (sign2 < 0.0) then
            ! We have gone from positive to negative, indicating the start
            ! of a new negative group.
            npairs = npairs + 1
            index_ue(i,npairs*2) = j
          else
            ! We have gone from negative to positive, indicating the end of
            ! the group.
            index_ue(i,npairs*2+1) = j - 1
          end if
        end if

        17 continue  ! Exclude points outside of the domain

      end do

      if (uwind(i,Ny) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 < 0.0) then
        index_ue(i,npairs*2+1) = Ny
      end if
      index_ue(i,1) = npairs
    end do

    ! Sweep looking for SOUTHERLY winds, looking for positive numbers.
    do j = 1, Ny

      if (vwind(1,j) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 > 0.0) then
        npairs = 1
        index_vs(j,2) = 1
      else
        npairs = 0
      end if

      do i = 2, Nx

        if (isnan(dem(i,j))) goto 18 ! Exclude points outside of the domain

        if (vwind(i-1,j) <= 0.0) then
          sign1 = -1.0
        else
          sign1 = 1.0
        end if
        if (vwind(i,j) <= 0.0) then
          sign2 = -1.0
        else
          sign2 = 1.0
        end if

        if (sign2 /= sign1) then
          ! We have a sign change.
          if (sign2 > 0.0) then
            ! We have gone from negative to positive, indicating the start
            ! of a new positive group.
            npairs = npairs + 1
            index_vs(j,npairs*2) = i
          else
            ! We have gone from positive to negative, indicating the end of
            ! the group.
            index_vs(j,npairs*2+1) = i - 1
          end if
        end if

        18 continue  ! Exclude points outside of the domain

      end do

      if (vwind(Nx,j) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 > 0.0) then
        index_vs(j,npairs*2+1) = Nx
      end if
      index_vs(j,1) = npairs
    end do

    ! Sweep looking for NORTHERLY winds, looking for negative numbers.
    do j = 1, Ny

      if (vwind(1,j) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 < 0.0) then
        npairs = 1
        index_vn(j,2) = 1
      else
        npairs = 0
      end if

      do i = 2, Nx

        if (isnan(dem(i,j))) goto 19 ! Exclude points outside of the domain

        if (vwind(i-1,j) <= 0.0) then
          sign1 = -1.0
        else
          sign1 = 1.0
        end if
        if (vwind(i,j) <= 0.0) then
          sign2 = -1.0
        else
          sign2 = 1.0
        end if

        if (sign2 /= sign1) then
          ! We have a sign change.
          if (sign2 < 0.0) then
            ! We have gone from positive to negative, indicating the start
            ! of a new negative group.
            npairs = npairs + 1
            index_vn(j,npairs*2) = i
          else
            ! We have gone from negative to positive, indicating the end of
            ! the group.
            index_vn(j,npairs*2+1) = i - 1
          end if
        end if

        19 continue  ! Exclude points outside of the domain

      end do

      if (vwind(Nx,j) <= 0.0) then
        sign1 = -1.0
      else
        sign1 = 1.0
      end if

      if (sign1 < 0.0) then
        index_vn(j,npairs*2+1) = Nx
      end if
      index_vn(j,1) = npairs
    end do

    end subroutine getdirection

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine SNOWTRAN3D_susp(Qs_u,Qs_v)

    use DRIVING, only: &
      dt                     ! Timestep (s)

    use PARAMMAPS, only: &
      vegsnowd_xy            ! Vegetation snow holding capacity (m)

    use STATE_VARIABLES, only: &
      Sice,                  &! Ice content of snow layers (kg/m^2)
      Sliq,                  &! Liquid content of snow layers (kg/m^2)
      Ds,                   &! Snow layer thicknesses (m)
      fsnow                  ! Snow cover fraction 

    use LANDUSE, only: &
      dem                    ! Terrain elevation (m)

    use PARAM_SNOWTRAN3D, only: &
      rho_snow               ! Constant snow density (kg/m^3)

    implicit none

    real, intent(inout) :: &
      Qs_u(Nx,Ny),          &! x component of either Qsalt or Qsusp (kg/m/s)
      Qs_v(Nx,Ny)            ! y component of either Qsalt or Qsusp (kg/m/s)

    real :: &
      dh_s_loss,            &! Snow depth loss due to either saltation or suspension (m)
      Ds_hard,              &! Hard snow thickness (m)
      snowdmin,             &! Minimum snow depth to allow transport (m)
      swe_loc                ! SWE in the snow covered part of the pixel (kg/m^2)

    integer :: &
      i,j,k,                &! Point counters
      istart,iend,          &! Point counters boundaries
      jstart,jend            ! Point counters boundaries  

  ! Consider WESTERLY winds.
  do i = 1, Nx
    do k = 1, index_uw(i,1)
      jstart = index_uw(i,k*2)+1
      jend = index_uw(i,k*2+1)
      do j = jstart, jend
        swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
        dSWE_s_u_loss(i,j) = dt * Qs_u(i,j) * fsnow(i,j) / delta_WE
        dSWE_s_u_gain(i,j) = dt * Qs_u(i,j-1) * fsnow(i,j-1) / delta_WE
        dSWE_s_u_loss(i,j) = min(dSWE_s_u_loss(i,j),swe_loc) ! No need to adjust Qs_u here because if thresholded, it will be done in the next if loop anyway
        if (dSWE_s_u_loss(i,j) > epsilon(dSWE_s_u_loss)) then
          call HS_FROM_SWE(dSWE_s_u_loss(i,j),dh_s_loss,i,j)
        else
          dSWE_s_u_loss(i,j) = 0.0
          dh_s_loss = 0.0
        end if
        dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
  
        ! Make adjustments for the case where there is no snow available
        ! on the ground (or captured within the vegetation) to be
        ! eroded.
        Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
        snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
        if (snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow)) then
          if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
            dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
            if (dh_s_loss > epsilon(dh_s_loss)) then
              call SWE_FROM_HS(dh_s_loss,dSWE_s_u_loss(i,j),i,j)
            else
              dSWE_s_u_loss(i,j) = 0.0
            end if
            dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
            Qs_u(i,j) = Qs_u(i,j-1) - dSWE_s_u(i,j) * delta_WE / dt / fsnow(i,j)
          end if
        else
          Qs_u(i,j) = 0.0
          dSWE_s_u_loss(i,j) = 0.0
          dSWE_s_u(i,j) = dSWE_s_u_gain(i,j)
        end if
      end do
    end do
  end do
  
  ! Consider EASTERLY winds.
  do i = 1, Nx
    do k = 1, index_ue(i,1)
      jend = index_ue(i,k*2)
      jstart = index_ue(i,k*2+1)-1
      do j = jstart, jend,-1
        swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
        dSWE_s_u_loss(i,j) = dt * Qs_u(i,j) * fsnow(i,j) / delta_WE
        dSWE_s_u_gain(i,j) = dt * Qs_u(i,j+1) * fsnow(i,j+1) / delta_WE
        dSWE_s_u_loss(i,j) = min(dSWE_s_u_loss(i,j),swe_loc) ! No need to adjust Qs_u here because if thresholded, it will be done in the next if loop anyway
        if (dSWE_s_u_loss(i,j) > epsilon(dSWE_s_u_loss)) then
          call HS_FROM_SWE(dSWE_s_u_loss(i,j),dh_s_loss,i,j)
        else
          dSWE_s_u_loss(i,j) = 0.0
          dh_s_loss = 0.0
        end if
        dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
  
        ! Make adjustments for the case where there is no snow available
        ! on the ground (or captured within the vegetation) to be
        ! eroded.
        Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
        snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
        if (snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow)) then
          if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
            dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
            if (dh_s_loss > epsilon(dh_s_loss)) then
              call SWE_FROM_HS(dh_s_loss,dSWE_s_u_loss(i,j),i,j)
            else
              dSWE_s_u_loss(i,j) = 0.0
            end if
            dSWE_s_u(i,j) = dSWE_s_u_gain(i,j) - dSWE_s_u_loss(i,j)
            Qs_u(i,j) = Qs_u(i,j+1) - dSWE_s_u(i,j) * delta_WE / dt / fsnow(i,j)
          end if
        else
          Qs_u(i,j) = 0.0
          dSWE_s_u_loss(i,j) = 0.0
          dSWE_s_u(i,j) = dSWE_s_u_gain(i,j)
        end if
      end do
    end do
  end do
  
  ! Consider SOUTHERLY winds.
  do j = 1, Ny
    do k = 1, index_vs(j,1)
      istart = index_vs(j,k*2)+1
      iend = index_vs(j,k*2+1)
      do i = istart, iend
        swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
        dSWE_s_v_loss(i,j) = dt * Qs_v(i,j) * fsnow(i,j) / delta_SN
        dSWE_s_v_gain(i,j) = dt * Qs_v(i-1,j) * fsnow(i-1,j) / delta_SN
        dSWE_s_v_loss(i,j) = min(dSWE_s_v_loss(i,j),swe_loc) ! No need to adjust Qs_v here because if thresholded, it will be done in the next if loop anyway
        if (dSWE_s_v_loss(i,j) > epsilon(dSWE_s_v_loss)) then
          call HS_FROM_SWE(dSWE_s_v_loss(i,j),dh_s_loss,i,j)
        else
          dSWE_s_v_loss(i,j) = 0.0
          dh_s_loss = 0.0
        end if
        dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
  
        ! Make adjustments for the case where there is no snow available
        ! on the ground (or captured within the vegetation) to be
        ! eroded.
        Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
        snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
        if (snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow)) then
          if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
            dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
            if (dh_s_loss > epsilon(dh_s_loss)) then
              call SWE_FROM_HS(dh_s_loss,dSWE_s_v_loss(i,j),i,j)
            else
              dSWE_s_v_loss(i,j) = 0.0
            end if
            dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
            Qs_v(i,j) = Qs_v(i-1,j) - dSWE_s_v(i,j) * delta_SN / dt / fsnow(i,j)
          end if
        else
          Qs_v(i,j) = 0.0
          dSWE_s_v_loss(i,j) = 0.0
          dSWE_s_v(i,j) = dSWE_s_v_gain(i,j)
        end if
      end do
    end do
  end do
  
  ! Consider NORTHERLY winds.
  do j = 1, Ny
    do k = 1, index_vn(j,1)
      iend = index_vn(j,k*2)
      istart = index_vn(j,k*2+1)-1
      do i = istart, iend,-1
        swe_loc = sum(Sice(:,i,j) + Sliq(:,i,j))
        dSWE_s_v_loss(i,j) = dt * Qs_v(i,j) * fsnow(i,j) / delta_SN
        dSWE_s_v_gain(i,j) = dt * Qs_v(i+1,j) * fsnow(i+1,j) / delta_SN
        dSWE_s_v_loss(i,j) = min(dSWE_s_v_loss(i,j),swe_loc) ! No need to adjust Qs_v here because if thresholded, it will be done in the next if loop anyway
        if (dSWE_s_v_loss(i,j) > epsilon(dSWE_s_v_loss)) then
          call HS_FROM_SWE(dSWE_s_v_loss(i,j),dh_s_loss,i,j)
        else
          dSWE_s_v_loss(i,j) = 0.0
          dh_s_loss = 0.0
        end if
        dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
  
        ! Make adjustments for the case where there is no snow available
        ! on the ground (or captured within the vegetation) to be
        ! eroded.
        Ds_hard = snowthickness(i,j) - Ds_soft(i,j)
        snowdmin = max(vegsnowd_xy(i,j),Ds_hard)
        if (snowthickness(i,j) > snowdmin .and. fsnow(i,j) > epsilon(fsnow)) then
          if (snowthickness(i,j) - dh_s_loss / fsnow(i,j) <= snowdmin) then
            dh_s_loss = (snowthickness(i,j) - snowdmin) * fsnow(i,j)
            if (dh_s_loss > epsilon(dh_s_loss)) then
              call SWE_FROM_HS(dh_s_loss,dSWE_s_v_loss(i,j),i,j)
            else
              dSWE_s_v_loss(i,j) = 0.0
            end if
            dSWE_s_v(i,j) = dSWE_s_v_gain(i,j) - dSWE_s_v_loss(i,j)
            Qs_v(i,j) = Qs_v(i+1,j) - dSWE_s_v(i,j) * delta_SN / dt / fsnow(i,j)
          end if
        else
          Qs_v(i,j) = 0.0
          dSWE_s_v_loss(i,j) = 0.0
          dSWE_s_v(i,j) = dSWE_s_v_gain(i,j)
        end if
      end do
    end do
  end do

  end subroutine SNOWTRAN3D_susp

  subroutine sumnewdepth(dSWE_s)

    use PARAMMAPS, only: &
      vegsnowd_xy            ! Vegetation snow holding capacity (m)

    use STATE_VARIABLES, only: &
      Ds                     ! Snow layer thicknesses (m)
      
    use LANDUSE, only: &
      dem                    ! Terrain elevation (m)
      
    use PARAM_SNOWTRAN3D, only: &
      rho_snow            ! Constant snow density (kg/m^3)

    real, intent(inout) :: &
      dSWE_s(Nx,Ny)          ! SWE change due to either saltation or suspension (kg/m^2)

    real :: &
      dh_s,                 &! Snow depth change due to either saltation or suspension (m)
      dh_s_gain,            &! Snow depth gain due to either saltation or suspension (m)
      dh_s_loss,            &! Snow depth loss due to either saltation or suspension (m)
      dSWE_s_loss,            &! SWE loss due to either saltation or suspension (kg/m^2)
      dSWE_s_gain,            &! SWE gain due to either saltation or suspension (kg/m^2)
      eps,                  &! Epsilon
      weight_u,             &! x weight for dSWE_s
      weight_v               ! y weight for dSWE_s

    integer :: &
      i,j,k                  ! Point counters

  
    ! Update the snow depth changes due to saltation transport from the
    ! the east and west, and north and south.
    eps = 1e-6
    do i = 2, Nx-1
      do j = 2, Ny-1
        if (isnan(dem(i,j))) goto 21 ! Exclude points outside of the domain

        ! LQ: I can't understand the meaning of this weighting, I keep it as original SNOWTRAN3D though
        !weight_u = abs(dh_s_u(i,j)) / &
        !           (abs(dh_s_u(i,j)) + abs(dh_s_v(i,j)) + eps)

        !weight_v = abs(dh_s_v(i,j)) / &
        !           (abs(dh_s_u(i,j)) + abs(dh_s_v(i,j)) + eps)

        !dSWE_s_u(i,j) = weight_u * dSWE_s_u(i,j)
        !dSWE_s_v(i,j) = weight_v * dSWE_s_v(i,j)
        !dSWE_s_u_gain(i,j) = weight_u * dSWE_s_u_gain(i,j)
        !dSWE_s_v_gain(i,j) = weight_v * dSWE_s_v_gain(i,j)
        !dSWE_s_u_loss(i,j) = weight_u * dSWE_s_u_loss(i,j)
        !dSWE_s_v_loss(i,j) = weight_v * dSWE_s_v_loss(i,j)

        dSWE_s(i,j) = dSWE_s_u(i,j) + dSWE_s_v(i,j)
        dSWE_s_gain = dSWE_s_u_gain(i,j) + dSWE_s_v_gain(i,j)
        dSWE_s_loss = dSWE_s_u_loss(i,j) + dSWE_s_v_loss(i,j)
        dh_s_gain = dSWE_s_gain / rho_snow
        if (dSWE_s_loss > epsilon(dSWE_s_loss)) then
          call HS_FROM_SWE(dSWE_s_loss,dh_s_loss,i,j)
        else
          dSWE_s_loss = 0.0
          dh_s_loss = 0.0
        end if
        dh_s = dh_s_gain - dh_s_loss

        Ds_soft(i,j) = max(Ds_soft(i,j) - dh_s_loss,0.0)

        if (dSWE_s_loss > epsilon(dSWE_s_loss) .and. dh_s_loss > epsilon(dh_s_loss)) then
          call SNOW_ABLATION(dh_s_loss,dSWE_s_loss,i,j)
        end if

        ! Net mass gain for this grid cell at this time step.
        if (dSWE_s_gain > epsilon(dSWE_s_gain) .and. dh_s_gain > epsilon(dh_s_gain)) then

          ! Add to the existing top layer.
          Sice0(i,j) = Sice0(i,j) + dSWE_s_gain
          snowdepth0(i,j) = snowdepth0(i,j) + dh_s_gain

        end if

        ! Update the snow layer thicknesses
        snowthickness(i,j) = sum(Ds(:,i,j))

        21 continue  ! Exclude points outside of the domain

      end do
    end do

    end subroutine sumnewdepth

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine surface_snow()

    use CONSTANTS, only: &
      Tm                  ! Melting point (K)

    use LANDUSE, only: &
      dem                 ! Terrain elevation (m)

    use DRIVING, only: &
      Ua,                &! Wind speed (m/s)
      zU,                &! Height of wind measurements (m)
      dt                  ! Timestep (s)

    use PARAMETERS, only : &
      rhos_min,          &! Minimum snow density (kg/m^3)
      rhos_max            ! Maximum snow density (kg/m^3)
      
    use PARAMMAPS, only: &
      z0_snow             ! Roughness length of snow (m)
      
    use PARAM_SNOWTRAN3D, only: &
      rho_snow            ! Constant snow density (kg/m^3)

    use STATE_VARIABLES, only: &
      Nsnow,             &! Number of snow layers
      fsnow,             &! Snow cover fraction 
      Sice,              &! Ice content of snow layers (kg/m^2)
      Sliq,              &! Liquid content of snow layers (kg/m^2)
      Ds,                &! Snow layer thicknesses (m)
      Tsnow               ! Snow layer temperatures (K)

    implicit none

    integer :: &
      i,j                 ! Point counters

    real :: &
      A1,                &! Coefficient A1 in Liston et al. (2007), eq. 17 p. 245 (m^-1)
      A2,                &! Coefficient A2 in Liston et al. (2007), eq. 17 p. 245 (m^3/kg)
      B,                 &! Coefficient B in Liston et al. (2007), eq. 17 p. 245 (K-1)
      U,                 &! Wind speed contribution to snow compaction
      rho_surf_snow,     &! Density of top snow layer  (kg/m^3)
      C,                 &! Density rate coefficient, C in Liston et al. (2007), eq. 17 p. 245
      alpha,             &! Coefficient E3 in Liston et al. (2007), eq. 18 p. 245 (m/s)
      windspd_2m          ! Windspeed at 2m height (m/s)

    ! Define the density rate coefficients.
    C = 0.10

    ! Define alpha. 
    alpha = 0.2

    do j = 1, Ny
      do i = 1, Nx

        if (isnan(dem(i,j))) goto 24 ! Exclude points outside of the domain

        ! Calculate the 2-m wind speed.
        windspd_2m = Ua(i,j) * log(2.0/z0_snow(i,j))/log(zU/z0_snow(i,j))

        ! Initialize coefficients
        A1 = 0.0013
        A2 = 0.021
        B = 0.08

        ! Evolve the near-surface snow density under the influence of
        ! temperature and snow-transporting wind speeds.

        ! Update the snow density of the soft snow layer.  Eliminate the
        ! wind speed influence for speeds below 5 m/s, but account for it
        ! if speeds are >= 5 m/s.
        if (windspd_2m >= 5.0) then
          U = 5.0 + 15.0 * (1.0 - exp(-(alpha*(windspd_2m - 5.0))))
        else
          U = 1.0
        end if

        rho_surf_snow = rho_snow
        if (Nsnow(i,j) > 0 .and. Ds(1,i,j) > epsilon(Ds)) then
          rho_surf_snow = (Sice(1,i,j) + Sliq(1,i,j)) / Ds(1,i,j) / fsnow(i,j)
          rho_surf_snow = rho_surf_snow + dt * &
                          (C * A1 * U * rho_surf_snow * &
                          exp((- B)*(Tm-Tsnow(1,i,j))) * exp((- A2)*rho_surf_snow))
          ! Bound the calculated density.
          rho_surf_snow = min(rhos_max,rho_surf_snow)
          rho_surf_snow = max(rhos_min,rho_surf_snow)
          ! Update surface snow layer thickness after wind compaction
          Ds(1,i,j) = (Sice(1,i,j) + Sliq(1,i,j)) / rho_surf_snow / fsnow(i,j)
        end if

        ! Calculate the snow threshold friction velocity.
        if (rho_surf_snow <= 300.0) then
          Utau_t(i,j) = 0.10 * exp(0.003 * rho_surf_snow)
        else
          Utau_t(i,j) = 0.005 * exp(0.013 * rho_surf_snow)
        end if

        24 continue  ! Exclude points outside of the domain

      end do
    end do

    end subroutine surface_snow

end module SNOWTRAN3d_interface


    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
